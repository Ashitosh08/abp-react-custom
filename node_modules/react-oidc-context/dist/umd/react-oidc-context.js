var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AuthContext: () => AuthContext,
  AuthProvider: () => AuthProvider,
  hasAuthParams: () => hasAuthParams,
  useAuth: () => useAuth,
  withAuth: () => withAuth
});

// src/AuthContext.ts
var import_react = __toESM(require("react"));
var AuthContext = import_react.default.createContext(void 0);
AuthContext.displayName = "AuthContext";

// src/AuthProvider.tsx
var import_react2 = __toESM(require("react"));
var import_oidc_client_ts = require("oidc-client-ts");

// src/AuthState.ts
var initialAuthState = {
  isLoading: true,
  isAuthenticated: false
};

// src/reducer.ts
var reducer = (state, action) => {
  switch (action.type) {
    case "INITIALISED":
    case "USER_LOADED":
      return {
        ...state,
        user: action.user,
        isLoading: false,
        isAuthenticated: action.user ? !action.user.expired : false,
        error: void 0
      };
    case "USER_UNLOADED":
      return {
        ...state,
        user: void 0,
        isAuthenticated: false
      };
    case "NAVIGATOR_INIT":
      return {
        ...state,
        isLoading: true,
        activeNavigator: action.method
      };
    case "NAVIGATOR_CLOSE":
      return {
        ...state,
        isLoading: false,
        activeNavigator: void 0
      };
    case "ERROR":
      return {
        ...state,
        isLoading: false,
        error: action.error
      };
    default:
      return {
        ...state,
        isLoading: false,
        error: new Error(`unknown type ${action["type"]}`)
      };
  }
};

// src/utils.ts
var hasAuthParams = (location = window.location) => {
  let searchParams = new URLSearchParams(location.search);
  if ((searchParams.get("code") || searchParams.get("error")) && searchParams.get("state")) {
    return true;
  }
  searchParams = new URLSearchParams(location.hash.replace("#", "?"));
  if ((searchParams.get("code") || searchParams.get("error")) && searchParams.get("state")) {
    return true;
  }
  return false;
};
var normalizeErrorFn = (fallbackMessage) => (error) => {
  if (error instanceof Error) {
    return error;
  }
  return new Error(fallbackMessage);
};
var loginError = normalizeErrorFn("Login failed");

// src/AuthProvider.tsx
var userManagerContextKeys = [
  "clearStaleState",
  "querySessionStatus",
  "revokeTokens",
  "startSilentRenew",
  "stopSilentRenew"
];
var navigatorKeys = [
  "signinPopup",
  "signinSilent",
  "signinRedirect",
  "signoutPopup",
  "signoutRedirect"
];
var unsupportedEnvironment = (fnName) => () => {
  throw new Error(`UserManager#${fnName} was called from an unsupported context. If this is a server-rendered page, defer this call with useEffect() or pass a custom UserManager implementation.`);
};
var defaultUserManagerImpl = typeof window === "undefined" ? null : import_oidc_client_ts.UserManager;
var AuthProvider = (props) => {
  const {
    children,
    onSigninCallback,
    skipSigninCallback,
    onRemoveUser,
    onSignoutRedirect,
    onSignoutPopup,
    implementation: UserManagerImpl = defaultUserManagerImpl,
    ...userManagerSettings
  } = props;
  const [userManager] = (0, import_react2.useState)(() => UserManagerImpl ? new UserManagerImpl(userManagerSettings) : { settings: userManagerSettings });
  const [state, dispatch] = (0, import_react2.useReducer)(reducer, initialAuthState);
  const userManagerContext = (0, import_react2.useMemo)(() => Object.assign({
    settings: userManager.settings,
    events: userManager.events
  }, Object.fromEntries(userManagerContextKeys.map((key) => {
    var _a, _b;
    return [
      key,
      (_b = (_a = userManager[key]) == null ? void 0 : _a.bind(userManager)) != null ? _b : unsupportedEnvironment(key)
    ];
  })), Object.fromEntries(navigatorKeys.map((key) => [
    key,
    userManager[key] ? async (...args) => {
      dispatch({ type: "NAVIGATOR_INIT", method: key });
      try {
        return await userManager[key](...args);
      } finally {
        dispatch({ type: "NAVIGATOR_CLOSE" });
      }
    } : unsupportedEnvironment(key)
  ]))), [userManager]);
  (0, import_react2.useEffect)(() => {
    if (!userManager)
      return;
    void (async () => {
      try {
        if (hasAuthParams() && !skipSigninCallback) {
          const user2 = await userManager.signinCallback();
          onSigninCallback && onSigninCallback(user2);
        }
        const user = await userManager.getUser();
        dispatch({ type: "INITIALISED", user });
      } catch (error) {
        dispatch({ type: "ERROR", error: loginError(error) });
      }
    })();
  }, [userManager, skipSigninCallback, onSigninCallback]);
  (0, import_react2.useEffect)(() => {
    if (!userManager)
      return void 0;
    const handleUserLoaded = (user) => {
      dispatch({ type: "USER_LOADED", user });
    };
    userManager.events.addUserLoaded(handleUserLoaded);
    const handleUserUnloaded = () => {
      dispatch({ type: "USER_UNLOADED" });
    };
    userManager.events.addUserUnloaded(handleUserUnloaded);
    const handleSilentRenewError = (error) => {
      dispatch({ type: "ERROR", error });
    };
    userManager.events.addSilentRenewError(handleSilentRenewError);
    return () => {
      userManager.events.removeUserLoaded(handleUserLoaded);
      userManager.events.removeUserUnloaded(handleUserUnloaded);
      userManager.events.removeSilentRenewError(handleSilentRenewError);
    };
  }, [userManager]);
  const removeUser = (0, import_react2.useCallback)(userManager ? () => userManager.removeUser().then(onRemoveUser) : unsupportedEnvironment("removeUser"), [userManager, onRemoveUser]);
  const signoutRedirect = (0, import_react2.useCallback)((args) => userManagerContext.signoutRedirect(args).then(onSignoutRedirect), [userManagerContext.signoutRedirect, onSignoutRedirect]);
  const signoutPopup = (0, import_react2.useCallback)((args) => userManagerContext.signoutPopup(args).then(onSignoutPopup), [userManagerContext.signoutPopup, onSignoutPopup]);
  return /* @__PURE__ */ import_react2.default.createElement(AuthContext.Provider, {
    value: {
      ...state,
      ...userManagerContext,
      removeUser,
      signoutRedirect,
      signoutPopup
    }
  }, children);
};

// src/useAuth.ts
var import_react3 = __toESM(require("react"));
var useAuth = () => {
  const context = import_react3.default.useContext(AuthContext);
  if (!context) {
    throw new Error("AuthProvider context is undefined, please verify you are calling useAuth() as child of a <AuthProvider> component.");
  }
  return context;
};

// src/withAuth.tsx
var import_react4 = __toESM(require("react"));
function withAuth(Component) {
  const displayName = `withAuth(${Component.displayName || Component.name})`;
  const C = (props) => {
    const auth = useAuth();
    return /* @__PURE__ */ import_react4.default.createElement(Component, {
      ...props,
      ...auth
    });
  };
  C.displayName = displayName;
  return C;
}
module.exports = __toCommonJS(src_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AuthContext,
  AuthProvider,
  hasAuthParams,
  useAuth,
  withAuth
});
//# sourceMappingURL=react-oidc-context.js.map

{
  "version": 3,
  "sources": ["../../src/AuthContext.ts", "../../src/AuthProvider.tsx", "../../src/AuthState.ts", "../../src/reducer.ts", "../../src/utils.ts", "../../src/useAuth.ts", "../../src/withAuth.tsx"],
  "sourcesContent": ["import React from \"react\";\nimport type {\n    UserManagerSettings, UserManagerEvents, User, SessionStatus,\n    SigninPopupArgs, SigninSilentArgs, SigninRedirectArgs,\n    SignoutRedirectArgs, SignoutPopupArgs, QuerySessionStatusArgs,\n    RevokeTokensTypes,\n} from \"oidc-client-ts\";\n\nimport type { AuthState } from \"./AuthState\";\n\n/**\n * @public\n */\nexport interface AuthContextProps extends AuthState {\n    /**\n     * UserManager functions. See [UserManager](https://github.com/authts/oidc-client-ts) for more details.\n     */\n    readonly settings: UserManagerSettings;\n    readonly events: UserManagerEvents;\n    clearStaleState(): Promise<void>;\n    removeUser(): Promise<void>;\n    signinPopup(args?: SigninPopupArgs): Promise<User>;\n    signinSilent(args?: SigninSilentArgs): Promise<User | null>;\n    signinRedirect(args?: SigninRedirectArgs): Promise<void>;\n    signoutRedirect(args?: SignoutRedirectArgs): Promise<void>;\n    signoutPopup(args?: SignoutPopupArgs): Promise<void>;\n    querySessionStatus(args?: QuerySessionStatusArgs): Promise<SessionStatus | null>;\n    revokeTokens(types?: RevokeTokensTypes): Promise<void>;\n    startSilentRenew(): void;\n    stopSilentRenew(): void;\n}\n\n/**\n * @public\n */\nexport const AuthContext = React.createContext<AuthContextProps | undefined>(undefined);\nAuthContext.displayName = \"AuthContext\";\n", "import React, { useCallback, useEffect, useMemo, useReducer, useState } from \"react\";\nimport { UserManager, UserManagerSettings, User } from \"oidc-client-ts\";\nimport type { SignoutRedirectArgs, SignoutPopupArgs } from \"oidc-client-ts\";\n\nimport { AuthContext } from \"./AuthContext\";\nimport { initialAuthState } from \"./AuthState\";\nimport { reducer } from \"./reducer\";\nimport { hasAuthParams, loginError } from \"./utils\";\n\n/**\n * @public\n */\nexport interface AuthProviderProps extends UserManagerSettings {\n    /**\n     * The child nodes your Provider has wrapped\n     */\n    children?: React.ReactNode;\n\n    /**\n     * On sign in callback hook. Can be a async function.\n     * Here you can remove the code and state parameters from the url when you are redirected from the authorize page.\n     *\n     * ```jsx\n     * const onSigninCallback = (_user: User | void): void => {\n     *     window.history.replaceState(\n     *         {},\n     *         document.title,\n     *         window.location.pathname\n     *     )\n     * }\n     * ```\n     */\n    onSigninCallback?: (user: User | void) => Promise<void> | void;\n\n    /**\n     * By default, if the page url has code/state params, this provider will call automatically the userManager.signinCallback.\n     * In some cases the code might be for something else (another OAuth SDK perhaps). In these\n     * instances you can instruct the client to ignore them.\n     *\n     * ```jsx\n     * <AuthProvider\n     *   skipSigninCallback={window.location.pathname === '/stripe-oauth-callback'}\n     * >\n     * ```\n     */\n    skipSigninCallback?: boolean;\n\n    /**\n     * On remove user hook. Can be a async function.\n     * Here you can change the url after the user is removed.\n     *\n     * ```jsx\n     * const onRemoveUser = (): void => {\n     *     // go to home after logout\n     *     window.location.pathname = \"\"\n     * }\n     * ```\n     */\n    onRemoveUser?: () => Promise<void> | void;\n\n    /**\n     * @deprecated On sign out redirect hook. Can be a async function.\n     */\n    onSignoutRedirect?: () => Promise<void> | void;\n\n    /**\n     * @deprecated On sign out popup hook. Can be a async function.\n     */\n    onSignoutPopup?: () => Promise<void> | void;\n\n    /**\n     * Allow passing a custom UserManager implementation\n     */\n    implementation?: typeof UserManager | null;\n}\n\nconst userManagerContextKeys = [\n    \"clearStaleState\",\n    \"querySessionStatus\",\n    \"revokeTokens\",\n    \"startSilentRenew\",\n    \"stopSilentRenew\",\n] as const;\nconst navigatorKeys = [\n    \"signinPopup\",\n    \"signinSilent\",\n    \"signinRedirect\",\n    \"signoutPopup\",\n    \"signoutRedirect\",\n] as const;\nconst unsupportedEnvironment = (fnName: string) => () => {\n    throw new Error(`UserManager#${fnName} was called from an unsupported context. If this is a server-rendered page, defer this call with useEffect() or pass a custom UserManager implementation.`);\n};\nconst defaultUserManagerImpl = typeof window === \"undefined\" ? null : UserManager;\n\n/**\n * Provides the AuthContext to its child components.\n * @public\n */\nexport const AuthProvider = (props: AuthProviderProps): JSX.Element => {\n    const {\n        children,\n\n        onSigninCallback,\n        skipSigninCallback,\n\n        onRemoveUser,\n        onSignoutRedirect,\n        onSignoutPopup,\n\n        implementation: UserManagerImpl = defaultUserManagerImpl,\n        ...userManagerSettings\n    } = props;\n\n    const [userManager] = useState(() => UserManagerImpl\n        ? new UserManagerImpl(userManagerSettings)\n        : { settings: userManagerSettings } as UserManager,\n    );\n    const [state, dispatch] = useReducer(reducer, initialAuthState);\n    const userManagerContext = useMemo(\n        () => Object.assign(\n            {\n                settings: userManager.settings,\n                events: userManager.events,\n            },\n            Object.fromEntries(\n                userManagerContextKeys.map((key) => [\n                    key,\n                    userManager[key]?.bind(userManager) ?? unsupportedEnvironment(key),\n                ]),\n            ) as Pick<UserManager, typeof userManagerContextKeys[number]>,\n            Object.fromEntries(\n                navigatorKeys.map((key) => [\n                    key,\n                    userManager[key]\n                        ? async (...args: never[]) => {\n                            dispatch({ type: \"NAVIGATOR_INIT\", method: key });\n                            try {\n                                return await userManager[key](...args);\n                            } finally {\n                                dispatch({ type: \"NAVIGATOR_CLOSE\" });\n                            }\n                        }\n                        : unsupportedEnvironment(key),\n                ]),\n            ) as Pick<UserManager, typeof navigatorKeys[number]>,\n        ),\n        [userManager],\n    );\n\n    useEffect(() => {\n        if (!userManager) return;\n        void (async (): Promise<void> => {\n            try {\n                // check if returning back from authority server\n                if (hasAuthParams() && !skipSigninCallback) {\n                    const user = await userManager.signinCallback();\n                    onSigninCallback && onSigninCallback(user);\n                }\n                const user = await userManager.getUser();\n                dispatch({ type: \"INITIALISED\", user });\n            } catch (error) {\n                dispatch({ type: \"ERROR\", error: loginError(error) });\n            }\n        })();\n    }, [userManager, skipSigninCallback, onSigninCallback]);\n\n    // register to userManager events\n    useEffect(() => {\n        if (!userManager) return undefined;\n        // event UserLoaded (e.g. initial load, silent renew success)\n        const handleUserLoaded = (user: User) => {\n            dispatch({ type: \"USER_LOADED\", user });\n        };\n        userManager.events.addUserLoaded(handleUserLoaded);\n\n        // event UserUnloaded (e.g. userManager.removeUser)\n        const handleUserUnloaded = () => {\n            dispatch({ type: \"USER_UNLOADED\" });\n        };\n        userManager.events.addUserUnloaded(handleUserUnloaded);\n\n        // event SilentRenewError (silent renew error)\n        const handleSilentRenewError = (error: Error) => {\n            dispatch({ type: \"ERROR\", error });\n        };\n        userManager.events.addSilentRenewError(handleSilentRenewError);\n\n        return () => {\n            userManager.events.removeUserLoaded(handleUserLoaded);\n            userManager.events.removeUserUnloaded(handleUserUnloaded);\n            userManager.events.removeSilentRenewError(handleSilentRenewError);\n        };\n    }, [userManager]);\n\n    const removeUser = useCallback(\n        userManager\n            ? () => userManager.removeUser().then(onRemoveUser)\n            : unsupportedEnvironment(\"removeUser\"),\n        [userManager, onRemoveUser],\n    );\n\n    const signoutRedirect = useCallback(\n        (args?: SignoutRedirectArgs) => userManagerContext.signoutRedirect(args).then(onSignoutRedirect),\n        [userManagerContext.signoutRedirect, onSignoutRedirect],\n    );\n\n    const signoutPopup = useCallback(\n        (args?: SignoutPopupArgs) => userManagerContext.signoutPopup(args).then(onSignoutPopup),\n        [userManagerContext.signoutPopup, onSignoutPopup],\n    );\n\n    return (\n        <AuthContext.Provider\n            value={{\n                ...state,\n                ...userManagerContext,\n                removeUser,\n                signoutRedirect,\n                signoutPopup,\n            }}\n        >\n            {children}\n        </AuthContext.Provider>\n    );\n};\n", "import type { User } from \"oidc-client-ts\";\n\n/**\n * The auth state which, when combined with the auth methods, make up the return object of the `useAuth` hook.\n *\n * @public\n */\nexport interface AuthState {\n    /**\n     * See [User](https://authts.github.io/oidc-client-ts/classes/User.html) for more details.\n     */\n    user?: User | null;\n\n    /**\n     * True when the library has been initialized and no navigator request is in progress.\n     */\n    isLoading: boolean;\n\n    /**\n     * True while the user has a valid access token.\n     */\n    isAuthenticated: boolean;\n\n    /**\n     * Tracks the status of most recent signin/signout request method.\n     */\n    activeNavigator?: \"signinRedirect\" | \"signinPopup\" | \"signinSilent\" | \"signoutRedirect\" | \"signoutPopup\";\n\n    /**\n     * Was there a signin or silent renew error?\n     */\n    error?: Error;\n}\n\n/**\n * The initial auth state.\n */\nexport const initialAuthState: AuthState = {\n    isLoading: true,\n    isAuthenticated: false,\n};\n", "import type { User } from \"oidc-client-ts\";\n\nimport type { AuthState } from \"./AuthState\";\n\ntype Action =\n    | { type: \"INITIALISED\" | \"USER_LOADED\"; user: User | null }\n    | { type: \"USER_UNLOADED\" }\n    | { type: \"NAVIGATOR_INIT\"; method: NonNullable<AuthState[\"activeNavigator\"]> }\n    | { type: \"NAVIGATOR_CLOSE\" }\n    | { type: \"ERROR\"; error: Error };\n\n/**\n * Handles how that state changes in the `useAuth` hook.\n */\nexport const reducer = (state: AuthState, action: Action): AuthState => {\n    switch (action.type) {\n        case \"INITIALISED\":\n        case \"USER_LOADED\":\n            return {\n                ...state,\n                user: action.user,\n                isLoading: false,\n                isAuthenticated: action.user ? !action.user.expired : false,\n                error: undefined,\n            };\n        case \"USER_UNLOADED\":\n            return {\n                ...state,\n                user: undefined,\n                isAuthenticated: false,\n            };\n        case \"NAVIGATOR_INIT\":\n            return {\n                ...state,\n                isLoading: true,\n                activeNavigator: action.method,\n            };\n        case \"NAVIGATOR_CLOSE\":\n            // we intentionally don't handle cases where multiple concurrent navigators are open\n            return {\n                ...state,\n                isLoading: false,\n                activeNavigator: undefined,\n            };\n        case \"ERROR\":\n            return {\n                ...state,\n                isLoading: false,\n                error: action.error,\n            };\n        default:\n            return {\n                ...state,\n                isLoading: false,\n                error: new Error(`unknown type ${action[\"type\"] as string}`),\n            };\n    }\n};\n", "/**\n * @public\n */\nexport const hasAuthParams = (location = window.location): boolean => {\n    // response_mode: query\n    let searchParams = new URLSearchParams(location.search);\n    if ((searchParams.get(\"code\") || searchParams.get(\"error\")) &&\n        searchParams.get(\"state\")) {\n        return true;\n    }\n\n    // response_mode: fragment\n    searchParams = new URLSearchParams(location.hash.replace(\"#\", \"?\"));\n    if ((searchParams.get(\"code\") || searchParams.get(\"error\")) &&\n        searchParams.get(\"state\")) {\n        return true;\n    }\n\n    return false;\n};\n\nconst normalizeErrorFn = (fallbackMessage: string) => (error: unknown): Error => {\n    if (error instanceof Error) {\n        return error;\n    }\n    return new Error(fallbackMessage);\n};\n\nexport const loginError = normalizeErrorFn(\"Login failed\");\n", "import React from \"react\";\n\nimport { AuthContext, AuthContextProps } from \"./AuthContext\";\n\n/**\n * @public\n */\nexport const useAuth = (): AuthContextProps => {\n    const context = React.useContext(AuthContext);\n\n    if (!context) {\n        throw new Error(\"AuthProvider context is undefined, please verify you are calling useAuth() as child of a <AuthProvider> component.\");\n    }\n\n    return context;\n};\n", "import React from \"react\";\n\nimport type { AuthContextProps } from \"./AuthContext\";\nimport { useAuth } from \"./useAuth\";\n\n/**\n * A public higher-order component to access the imperative API\n * @public\n */\nexport function withAuth<P extends AuthContextProps>(\n    Component: React.ComponentType<P>,\n): React.ComponentType<Omit<P, keyof AuthContextProps>> {\n    const displayName = `withAuth(${Component.displayName || Component.name})`;\n    const C: React.FC<Omit<P, keyof AuthContextProps>> = (props) => {\n        const auth = useAuth();\n\n        return <Component {...(props as P)} {...auth} />;\n    };\n\n    C.displayName = displayName;\n\n    return C;\n}\n"],
  "mappings": "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",
  "names": []
}

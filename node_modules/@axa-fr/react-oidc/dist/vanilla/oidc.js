"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Oidc = void 0;
var appauth_1 = require("@openid/appauth");
var noHashQueryStringUtils_1 = require("./noHashQueryStringUtils");
var initWorker_1 = require("./initWorker");
var memoryStorageBackend_1 = require("./memoryStorageBackend");
var initSession_1 = require("./initSession");
var timer_1 = __importDefault(require("./timer"));
var isInIframe = function () {
    try {
        return window.self !== window.top;
    }
    catch (e) {
        return true;
    }
};
var idTokenPayload = function (token) {
    var base64Url = token.split('.')[1];
    var base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    var jsonPayload = decodeURIComponent(atob(base64).split('').map(function (c) {
        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
    }).join(''));
    return JSON.parse(jsonPayload);
};
var countLetter = function (str, find) {
    return (str.split(find)).length - 1;
};
var extractAccessTokenPayload = function (tokens) {
    if (tokens.accessTokenPayload) {
        return tokens.accessTokenPayload;
    }
    var accessToken = tokens.accessToken;
    try {
        if (!accessToken || countLetter(accessToken, '.') === 2) {
            return null;
        }
        return JSON.parse(atob(accessToken.split('.')[1]));
    }
    catch (e) {
        console.warn(e);
    }
    return null;
};
var refresh_token_scope = "offline_access";
var oidcDatabase = {};
var oidcFactory = function (configuration, name) {
    if (name === void 0) { name = "default"; }
    if (oidcDatabase[name]) {
        return oidcDatabase[name];
    }
    oidcDatabase[name] = new Oidc(configuration, name);
    return oidcDatabase[name];
};
var loginCallbackWithAutoTokensRenewAsync = function (oidc) { return __awaiter(void 0, void 0, void 0, function () {
    var response, tokens, _a, _b;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0: return [4 /*yield*/, oidc.loginCallbackAsync()];
            case 1:
                response = _c.sent();
                tokens = response.tokens;
                _a = oidc;
                return [4 /*yield*/, setTokensAsync(oidc.serviceWorker, tokens)];
            case 2:
                _a.tokens = _c.sent();
                if (!!oidc.serviceWorker) return [3 /*break*/, 4];
                return [4 /*yield*/, oidc.session.setTokens(oidc.tokens)];
            case 3:
                _c.sent();
                _c.label = 4;
            case 4:
                oidc.publishEvent(Oidc.eventNames.token_aquired, oidc.tokens);
                _b = oidc;
                return [4 /*yield*/, autoRenewTokensAsync(oidc, tokens.refreshToken, oidc.tokens.expiresAt)];
            case 5:
                _b.timeoutId = _c.sent();
                return [2 /*return*/, response.state];
        }
    });
}); };
var autoRenewTokensAsync = function (oidc, refreshToken, expiresAt) { return __awaiter(void 0, void 0, void 0, function () {
    var refreshTimeBeforeTokensExpirationInSecond;
    var _a;
    return __generator(this, function (_b) {
        refreshTimeBeforeTokensExpirationInSecond = (_a = oidc.configuration.refresh_time_before_tokens_expiration_in_second) !== null && _a !== void 0 ? _a : 60;
        return [2 /*return*/, timer_1.default.setTimeout(function () { return __awaiter(void 0, void 0, void 0, function () {
                var currentTimeUnixSecond, timeInfo, tokens, _a, _b, _c;
                return __generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            currentTimeUnixSecond = new Date().getTime() / 1000;
                            timeInfo = { timeLeft: ((expiresAt - refreshTimeBeforeTokensExpirationInSecond) - currentTimeUnixSecond) };
                            oidc.publishEvent(Oidc.eventNames.token_timer, timeInfo);
                            if (!(currentTimeUnixSecond > (expiresAt - refreshTimeBeforeTokensExpirationInSecond))) return [3 /*break*/, 6];
                            return [4 /*yield*/, oidc.refreshTokensAsync(refreshToken)];
                        case 1:
                            tokens = _d.sent();
                            _a = oidc;
                            return [4 /*yield*/, setTokensAsync(oidc.serviceWorker, tokens)];
                        case 2:
                            _a.tokens = _d.sent();
                            if (!!oidc.serviceWorker) return [3 /*break*/, 4];
                            return [4 /*yield*/, oidc.session.setTokens(oidc.tokens)];
                        case 3:
                            _d.sent();
                            _d.label = 4;
                        case 4:
                            if (!oidc.tokens) {
                                return [2 /*return*/];
                            }
                            oidc.publishEvent(Oidc.eventNames.token_renewed, oidc.tokens);
                            _b = oidc;
                            return [4 /*yield*/, autoRenewTokensAsync(oidc, tokens.refreshToken, oidc.tokens.expiresAt)];
                        case 5:
                            _b.timeoutId = _d.sent();
                            return [3 /*break*/, 8];
                        case 6:
                            _c = oidc;
                            return [4 /*yield*/, autoRenewTokensAsync(oidc, refreshToken, expiresAt)];
                        case 7:
                            _c.timeoutId = _d.sent();
                            _d.label = 8;
                        case 8: return [2 /*return*/];
                    }
                });
            }); }, 1000)];
    });
}); };
var userInfoAsync = function (oidc) { return __awaiter(void 0, void 0, void 0, function () {
    var accessToken, oidcServerConfiguration, url, fetchUserInfo, userInfo;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (oidc.userInfo != null) {
                    return [2 /*return*/, oidc.userInfo];
                }
                if (!oidc.tokens) {
                    return [2 /*return*/, null];
                }
                accessToken = oidc.tokens.accessToken;
                return [4 /*yield*/, oidc.initAsync(oidc.configuration.authority, oidc.configuration.authority_configuration)];
            case 1:
                oidcServerConfiguration = _a.sent();
                url = oidcServerConfiguration.userInfoEndpoint;
                fetchUserInfo = function (accessToken) { return __awaiter(void 0, void 0, void 0, function () {
                    var res;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, fetch(url, {
                                    headers: {
                                        authorization: "Bearer ".concat(accessToken)
                                    }
                                })];
                            case 1:
                                res = _a.sent();
                                if (res.status != 200) {
                                    return [2 /*return*/, null];
                                }
                                return [2 /*return*/, res.json()];
                        }
                    });
                }); };
                return [4 /*yield*/, fetchUserInfo(accessToken)];
            case 2:
                userInfo = _a.sent();
                oidc.userInfo = userInfo;
                return [2 /*return*/, userInfo];
        }
    });
}); };
var setTokensAsync = function (serviceWorker, tokens) { return __awaiter(void 0, void 0, void 0, function () {
    var accessTokenPayload, expiresAt;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (!(tokens == null)) return [3 /*break*/, 3];
                if (!serviceWorker) return [3 /*break*/, 2];
                return [4 /*yield*/, serviceWorker.clearAsync()];
            case 1:
                _a.sent();
                _a.label = 2;
            case 2: return [2 /*return*/, null];
            case 3:
                if (!serviceWorker) return [3 /*break*/, 5];
                return [4 /*yield*/, serviceWorker.getAccessTokenPayloadAsync()];
            case 4:
                accessTokenPayload = _a.sent();
                return [3 /*break*/, 6];
            case 5:
                accessTokenPayload = extractAccessTokenPayload(tokens);
                _a.label = 6;
            case 6:
                expiresAt = tokens.issuedAt + tokens.expiresIn;
                return [2 /*return*/, __assign(__assign({}, tokens), { idTokenPayload: idTokenPayload(tokens.idToken), accessTokenPayload: accessTokenPayload, expiresAt: expiresAt })];
        }
    });
}); };
var eventNames = {
    service_worker_not_supported_by_browser: "service_worker_not_supported_by_browser",
    token_aquired: "token_aquired",
    token_renewed: "token_renewed",
    token_timer: "token_timer",
    loginAsync_begin: "loginAsync_begin",
    loginAsync_error: "loginAsync_error",
    loginCallbackAsync_begin: "loginCallbackAsync_begin",
    loginCallbackAsync_end: "loginCallbackAsync_end",
    loginCallbackAsync_error: "loginCallbackAsync_error",
    refreshTokensAsync_begin: "refreshTokensAsync_begin",
    refreshTokensAsync_end: "refreshTokensAsync_end",
    refreshTokensAsync_error: "refreshTokensAsync_error",
    refreshTokensAsync_silent_begin: "refreshTokensAsync_silent_begin",
    refreshTokensAsync_silent_end: "refreshTokensAsync_silent_end",
    refreshTokensAsync_silent_error: "refreshTokensAsync_silent_error",
    tryKeepExistingSessionAsync_begin: "tryKeepExistingSessionAsync_begin",
    tryKeepExistingSessionAsync_end: "tryKeepExistingSessionAsync_end",
    tryKeepExistingSessionAsync_error: "tryKeepExistingSessionAsync_error",
    silentSigninAsync_begin: "silentSigninAsync_begin",
    silentSigninAsync_end: "silentSigninAsync_end",
    silentSigninAsync_error: "silentSigninAsync_error",
};
var getRandomInt = function (max) {
    return Math.floor(Math.random() * max);
};
var Oidc = /** @class */ (function () {
    function Oidc(configuration, configurationName) {
        if (configurationName === void 0) { configurationName = "default"; }
        this.configuration = configuration;
        this.configurationName = configurationName;
        this.tokens = null;
        this.userInfo = null;
        this.events = [];
        this.timeoutId = null;
        this.serviceWorker = null;
        this.session = null;
        this.refreshTokensAsync.bind(this);
        this.loginCallbackWithAutoTokensRenewAsync.bind(this);
        this.initAsync.bind(this);
        this.loginCallbackAsync.bind(this);
        this.subscriveEvents.bind(this);
        this.removeEventSubscription.bind(this);
        this.publishEvent.bind(this);
        this.destroyAsync.bind(this);
    }
    Oidc.prototype.subscriveEvents = function (func) {
        var id = getRandomInt(9999999999999).toString();
        this.events.push({ id: id, func: func });
        return id;
    };
    Oidc.prototype.removeEventSubscription = function (id) {
        var newEvents = this.events.filter(function (e) { return e.id === id; });
        this.events = newEvents;
    };
    Oidc.prototype.publishEvent = function (eventName, data) {
        this.events.forEach(function (event) {
            event.func(eventName, data);
        });
    };
    Oidc.getOrCreate = function (configuration, name) {
        if (name === void 0) { name = "default"; }
        return oidcFactory(configuration, name);
    };
    Oidc.get = function (name) {
        if (name === void 0) { name = "default"; }
        return oidcDatabase[name];
    };
    Oidc.prototype.silentSigninCallbackFromIFrame = function () {
        if (this.configuration.silent_redirect_uri) {
            window.top.postMessage("".concat(this.configurationName, "_oidc_tokens:").concat(JSON.stringify(this.tokens)), window.location.origin);
        }
    };
    Oidc.prototype.silentSigninAsync = function () {
        return __awaiter(this, void 0, void 0, function () {
            var configuration, link, iframe, self, promise;
            return __generator(this, function (_a) {
                if (!this.configuration.silent_redirect_uri) {
                    return [2 /*return*/, Promise.resolve(null)];
                }
                this.publishEvent(eventNames.silentSigninAsync_begin, {});
                configuration = this.configuration;
                link = configuration.silent_redirect_uri;
                iframe = document.createElement('iframe');
                iframe.width = "0px";
                iframe.height = "0px";
                iframe.id = "".concat(this.configurationName, "_oidc_iframe");
                iframe.setAttribute("src", link);
                document.body.appendChild(iframe);
                self = this;
                promise = new Promise(function (resolve, reject) {
                    try {
                        var isResolved_1 = false;
                        window.onmessage = function (e) {
                            var key = "".concat(self.configurationName, "_oidc_tokens:");
                            if (e.data && typeof (e.data) === "string" && e.data.startsWith(key)) {
                                if (!isResolved_1) {
                                    self.publishEvent(eventNames.silentSigninAsync_end, {});
                                    resolve(JSON.parse(e.data.replace(key, '')));
                                    iframe.remove();
                                    isResolved_1 = true;
                                }
                            }
                        };
                        var silentSigninTimeout = configuration.silent_signin_timeout ? configuration.silent_signin_timeout : 12000;
                        setTimeout(function () {
                            if (!isResolved_1) {
                                reject("timeout");
                                self.publishEvent(eventNames.silentSigninAsync_error, new Error("timeout"));
                                iframe.remove();
                                isResolved_1 = true;
                            }
                        }, silentSigninTimeout);
                    }
                    catch (e) {
                        iframe.remove();
                        reject(e);
                        self.publishEvent(eventNames.silentSigninAsync_error, e);
                    }
                });
                return [2 /*return*/, promise];
            });
        });
    };
    Oidc.prototype.initAsync = function (authority, authorityConfiguration) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (authorityConfiguration != null) {
                            return [2 /*return*/, new appauth_1.AuthorizationServiceConfiguration({
                                    authorization_endpoint: authorityConfiguration.authorization_endpoint,
                                    end_session_endpoint: authorityConfiguration.end_session_endpoint,
                                    revocation_endpoint: authorityConfiguration.revocation_endpoint,
                                    token_endpoint: authorityConfiguration.token_endpoint,
                                    userinfo_endpoint: authorityConfiguration.userinfo_endpoint
                                })];
                        }
                        return [4 /*yield*/, appauth_1.AuthorizationServiceConfiguration.fetchFromIssuer(authority, new appauth_1.FetchRequestor())];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Oidc.prototype.tryKeepExistingSessionAsync = function () {
        return __awaiter(this, void 0, void 0, function () {
            var serviceWorker, configuration, oidcServerConfiguration, tokens, updatedTokens, _a, _b, session, tokens, updatedTokens, _c, _d, exception_1;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (this.tokens != null) {
                            return [2 /*return*/, false];
                        }
                        this.publishEvent(eventNames.tryKeepExistingSessionAsync_begin, {});
                        _e.label = 1;
                    case 1:
                        _e.trys.push([1, 15, , 18]);
                        configuration = this.configuration;
                        return [4 /*yield*/, this.initAsync(configuration.authority, configuration.authority_configuration)];
                    case 2:
                        oidcServerConfiguration = _e.sent();
                        return [4 /*yield*/, (0, initWorker_1.initWorkerAsync)(configuration.service_worker_relative_url, this.configurationName)];
                    case 3:
                        serviceWorker = _e.sent();
                        if (!serviceWorker) return [3 /*break*/, 9];
                        return [4 /*yield*/, serviceWorker.initAsync(oidcServerConfiguration, "tryKeepExistingSessionAsync")];
                    case 4:
                        tokens = (_e.sent()).tokens;
                        if (!tokens) return [3 /*break*/, 8];
                        serviceWorker.startKeepAliveServiceWorker();
                        return [4 /*yield*/, this.refreshTokensAsync(tokens.refresh_token, true)];
                    case 5:
                        updatedTokens = _e.sent();
                        // @ts-ignore
                        _a = this;
                        return [4 /*yield*/, setTokensAsync(serviceWorker, updatedTokens)];
                    case 6:
                        // @ts-ignore
                        _a.tokens = _e.sent();
                        this.serviceWorker = serviceWorker;
                        // @ts-ignore
                        _b = this;
                        return [4 /*yield*/, autoRenewTokensAsync(this, updatedTokens.refreshToken, this.tokens.expiresAt)];
                    case 7:
                        // @ts-ignore
                        _b.timeoutId = _e.sent();
                        this.publishEvent(eventNames.tryKeepExistingSessionAsync_end, { success: true, message: "tokens inside ServiceWorker are valid" });
                        return [2 /*return*/, true];
                    case 8:
                        this.publishEvent(eventNames.tryKeepExistingSessionAsync_end, { success: false, message: "no exiting session found" });
                        return [3 /*break*/, 14];
                    case 9:
                        if (configuration.service_worker_relative_url) {
                            this.publishEvent(eventNames.service_worker_not_supported_by_browser, {
                                message: "service worker is not supported by this browser"
                            });
                        }
                        session = (0, initSession_1.initSession)(this.configurationName);
                        return [4 /*yield*/, session.initAsync()];
                    case 10:
                        tokens = (_e.sent()).tokens;
                        if (!tokens) return [3 /*break*/, 14];
                        return [4 /*yield*/, this.refreshTokensAsync(tokens.refreshToken, true)];
                    case 11:
                        updatedTokens = _e.sent();
                        // @ts-ignore
                        _c = this;
                        return [4 /*yield*/, setTokensAsync(serviceWorker, updatedTokens)];
                    case 12:
                        // @ts-ignore
                        _c.tokens = _e.sent();
                        session.setTokens(this.tokens);
                        this.session = session;
                        // @ts-ignore
                        _d = this;
                        return [4 /*yield*/, autoRenewTokensAsync(this, updatedTokens.refreshToken, this.tokens.expiresAt)];
                    case 13:
                        // @ts-ignore
                        _d.timeoutId = _e.sent();
                        this.publishEvent(eventNames.tryKeepExistingSessionAsync_end, { success: true, message: "tokens inside ServiceWorker are valid" });
                        return [2 /*return*/, true];
                    case 14:
                        this.publishEvent(eventNames.tryKeepExistingSessionAsync_end, { success: false, message: "no service worker" });
                        return [2 /*return*/, false];
                    case 15:
                        exception_1 = _e.sent();
                        if (!serviceWorker) return [3 /*break*/, 17];
                        return [4 /*yield*/, serviceWorker.clearAsync()];
                    case 16:
                        _e.sent();
                        _e.label = 17;
                    case 17:
                        this.publishEvent(eventNames.tryKeepExistingSessionAsync_error, "tokens inside ServiceWorker are invalid");
                        return [2 /*return*/, false];
                    case 18: return [2 /*return*/];
                }
            });
        });
    };
    Oidc.prototype.loginAsync = function (callbackPath, extras, installServiceWorker) {
        if (callbackPath === void 0) { callbackPath = undefined; }
        if (extras === void 0) { extras = null; }
        if (installServiceWorker === void 0) { installServiceWorker = true; }
        return __awaiter(this, void 0, void 0, function () {
            var location_1, url, state, configuration, serviceWorker, oidcServerConfiguration, isServiceWorkerProxyActive, storage, session, authorizationHandler, authRequest, exception_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 8, , 9]);
                        location_1 = window.location;
                        url = callbackPath || location_1.pathname + (location_1.search || '') + (location_1.hash || '');
                        state = url;
                        this.publishEvent(eventNames.loginAsync_begin, {});
                        configuration = this.configuration;
                        // Security we cannot loggin from Iframe
                        if (!configuration.silent_redirect_uri && isInIframe()) {
                            throw new Error("Login from iframe is forbidden");
                        }
                        return [4 /*yield*/, (0, initWorker_1.initWorkerAsync)(configuration.service_worker_relative_url, this.configurationName)];
                    case 1:
                        serviceWorker = _a.sent();
                        return [4 /*yield*/, this.initAsync(configuration.authority, configuration.authority_configuration)];
                    case 2:
                        oidcServerConfiguration = _a.sent();
                        if (!(serviceWorker && installServiceWorker)) return [3 /*break*/, 4];
                        return [4 /*yield*/, serviceWorker.isServiceWorkerProxyActiveAsync()];
                    case 3:
                        isServiceWorkerProxyActive = _a.sent();
                        if (!isServiceWorkerProxyActive) {
                            window.location.href = configuration.redirect_uri + "/service-worker-install?callbackPath=" + encodeURIComponent(url);
                            return [2 /*return*/];
                        }
                        _a.label = 4;
                    case 4:
                        storage = void 0;
                        if (!serviceWorker) return [3 /*break*/, 6];
                        serviceWorker.startKeepAliveServiceWorker();
                        return [4 /*yield*/, serviceWorker.initAsync(oidcServerConfiguration, "loginAsync")];
                    case 5:
                        _a.sent();
                        storage = new memoryStorageBackend_1.MemoryStorageBackend(serviceWorker.saveItemsAsync, {});
                        return [3 /*break*/, 7];
                    case 6:
                        session = (0, initSession_1.initSession)(this.configurationName);
                        storage = new memoryStorageBackend_1.MemoryStorageBackend(session.saveItemsAsync, {});
                        _a.label = 7;
                    case 7:
                        authorizationHandler = new appauth_1.RedirectRequestHandler(storage, new noHashQueryStringUtils_1.NoHashQueryStringUtils(), window.location, new appauth_1.DefaultCrypto());
                        authRequest = new appauth_1.AuthorizationRequest({
                            client_id: configuration.client_id,
                            redirect_uri: configuration.redirect_uri,
                            scope: configuration.scope,
                            response_type: appauth_1.AuthorizationRequest.RESPONSE_TYPE_CODE,
                            state: state,
                            extras: extras !== null && extras !== void 0 ? extras : configuration.extras
                        });
                        authorizationHandler.performAuthorizationRequest(oidcServerConfiguration, authRequest);
                        return [3 /*break*/, 9];
                    case 8:
                        exception_2 = _a.sent();
                        this.publishEvent(eventNames.loginAsync_error, exception_2);
                        throw exception_2;
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    Oidc.prototype.loginCallbackAsync = function () {
        return __awaiter(this, void 0, void 0, function () {
            var configuration_1, clientId_1, redirectURL_1, authority, oidcServerConfiguration_1, serviceWorker, storage_1, items, session, items, promise, exception_3;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 8, , 9]);
                        this.publishEvent(eventNames.loginCallbackAsync_begin, {});
                        configuration_1 = this.configuration;
                        clientId_1 = configuration_1.client_id;
                        redirectURL_1 = configuration_1.redirect_uri;
                        authority = configuration_1.authority;
                        return [4 /*yield*/, this.initAsync(authority, configuration_1.authority_configuration)];
                    case 1:
                        oidcServerConfiguration_1 = _a.sent();
                        return [4 /*yield*/, (0, initWorker_1.initWorkerAsync)(configuration_1.service_worker_relative_url, this.configurationName)];
                    case 2:
                        serviceWorker = _a.sent();
                        storage_1 = null;
                        if (!serviceWorker) return [3 /*break*/, 5];
                        serviceWorker.startKeepAliveServiceWorker();
                        this.serviceWorker = serviceWorker;
                        return [4 /*yield*/, serviceWorker.initAsync(oidcServerConfiguration_1, "loginCallbackAsync")];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, serviceWorker.loadItemsAsync()];
                    case 4:
                        items = _a.sent();
                        storage_1 = new memoryStorageBackend_1.MemoryStorageBackend(serviceWorker.saveItemsAsync, items);
                        return [3 /*break*/, 7];
                    case 5:
                        session = (0, initSession_1.initSession)(this.configurationName);
                        this.session = session;
                        return [4 /*yield*/, session.loadItemsAsync()];
                    case 6:
                        items = _a.sent();
                        storage_1 = new memoryStorageBackend_1.MemoryStorageBackend(session.saveItemsAsync, items);
                        _a.label = 7;
                    case 7:
                        promise = new Promise(function (resolve, reject) {
                            var tokenHandler = new appauth_1.BaseTokenRequestHandler(new appauth_1.FetchRequestor());
                            // @ts-ignore
                            var authorizationHandler = new appauth_1.RedirectRequestHandler(storage_1, new noHashQueryStringUtils_1.NoHashQueryStringUtils(), window.location, new appauth_1.DefaultCrypto());
                            var notifier = new appauth_1.AuthorizationNotifier();
                            authorizationHandler.setAuthorizationNotifier(notifier);
                            notifier.setAuthorizationListener(function (request, response, error) { return __awaiter(_this, void 0, void 0, function () {
                                var extras, _i, _a, _b, key, value, tokenRequest, tokenResponse, exception_4;
                                return __generator(this, function (_c) {
                                    switch (_c.label) {
                                        case 0:
                                            if (error) {
                                                reject(error);
                                            }
                                            if (!response) {
                                                return [2 /*return*/];
                                            }
                                            extras = null;
                                            if (request && request.internal) {
                                                extras = {};
                                                extras.code_verifier = request.internal.code_verifier;
                                                if (configuration_1.token_request_extras) {
                                                    for (_i = 0, _a = Object.entries(configuration_1.token_request_extras); _i < _a.length; _i++) {
                                                        _b = _a[_i], key = _b[0], value = _b[1];
                                                        extras[key] = value;
                                                    }
                                                }
                                            }
                                            tokenRequest = new appauth_1.TokenRequest({
                                                client_id: clientId_1,
                                                redirect_uri: redirectURL_1,
                                                grant_type: appauth_1.GRANT_TYPE_AUTHORIZATION_CODE,
                                                code: response.code,
                                                refresh_token: undefined,
                                                extras: extras,
                                            });
                                            _c.label = 1;
                                        case 1:
                                            _c.trys.push([1, 3, , 4]);
                                            return [4 /*yield*/, tokenHandler.performTokenRequest(oidcServerConfiguration_1, tokenRequest)];
                                        case 2:
                                            tokenResponse = _c.sent();
                                            resolve({ tokens: tokenResponse, state: request.state });
                                            this.publishEvent(eventNames.loginCallbackAsync_end, {});
                                            return [3 /*break*/, 4];
                                        case 3:
                                            exception_4 = _c.sent();
                                            this.publishEvent(eventNames.loginCallbackAsync_error, exception_4);
                                            console.error(exception_4);
                                            reject(exception_4);
                                            return [3 /*break*/, 4];
                                        case 4: return [2 /*return*/];
                                    }
                                });
                            }); });
                            authorizationHandler.completeAuthorizationRequestIfPossible();
                        });
                        return [2 /*return*/, promise];
                    case 8:
                        exception_3 = _a.sent();
                        console.error(exception_3);
                        this.publishEvent(eventNames.loginCallbackAsync_error, exception_3);
                        throw exception_3;
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    Oidc.prototype.refreshTokensAsync = function (refreshToken, silentEvent) {
        if (silentEvent === void 0) { silentEvent = false; }
        return __awaiter(this, void 0, void 0, function () {
            var localSilentSigninAsync, configuration, clientId, redirectUri, authority, tokenHandler, extras, _i, _a, _b, key, value, request, oidcServerConfiguration, token_response, exception_5;
            var _this = this;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        localSilentSigninAsync = function (exception) {
                            if (exception === void 0) { exception = null; }
                            return __awaiter(_this, void 0, void 0, function () {
                                var silent_token_response, exceptionSilent_1;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            _a.trys.push([0, 2, , 3]);
                                            return [4 /*yield*/, this.silentSigninAsync()];
                                        case 1:
                                            silent_token_response = _a.sent();
                                            if (silent_token_response) {
                                                return [2 /*return*/, silent_token_response];
                                            }
                                            return [3 /*break*/, 3];
                                        case 2:
                                            exceptionSilent_1 = _a.sent();
                                            console.error(exceptionSilent_1);
                                            return [3 /*break*/, 3];
                                        case 3:
                                            this.publishEvent(silentEvent ? eventNames.refreshTokensAsync_silent_error : eventNames.refreshTokensAsync_error, exception);
                                            return [2 /*return*/, null];
                                    }
                                });
                            });
                        };
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 6, , 8]);
                        this.publishEvent(silentEvent ? eventNames.refreshTokensAsync_silent_begin : eventNames.refreshTokensAsync_begin, {});
                        configuration = this.configuration;
                        clientId = configuration.client_id;
                        redirectUri = configuration.redirect_uri;
                        authority = configuration.authority;
                        if (!!configuration.scope.split(" ").find(function (s) { return s === refresh_token_scope; })) return [3 /*break*/, 3];
                        return [4 /*yield*/, localSilentSigninAsync()];
                    case 2: return [2 /*return*/, _c.sent()];
                    case 3:
                        tokenHandler = new appauth_1.BaseTokenRequestHandler(new appauth_1.FetchRequestor());
                        extras = undefined;
                        if (configuration.token_request_extras) {
                            extras = {};
                            for (_i = 0, _a = Object.entries(configuration.token_request_extras); _i < _a.length; _i++) {
                                _b = _a[_i], key = _b[0], value = _b[1];
                                extras[key] = value;
                            }
                        }
                        request = new appauth_1.TokenRequest({
                            client_id: clientId,
                            redirect_uri: redirectUri,
                            grant_type: appauth_1.GRANT_TYPE_REFRESH_TOKEN,
                            code: undefined,
                            refresh_token: refreshToken,
                            extras: extras
                        });
                        return [4 /*yield*/, this.initAsync(authority, configuration.authority_configuration)];
                    case 4:
                        oidcServerConfiguration = _c.sent();
                        return [4 /*yield*/, tokenHandler.performTokenRequest(oidcServerConfiguration, request)];
                    case 5:
                        token_response = _c.sent();
                        this.publishEvent(silentEvent ? eventNames.refreshTokensAsync_silent_end : eventNames.refreshTokensAsync_end, token_response);
                        return [2 /*return*/, token_response];
                    case 6:
                        exception_5 = _c.sent();
                        console.error(exception_5);
                        return [4 /*yield*/, localSilentSigninAsync(exception_5)];
                    case 7: return [2 /*return*/, _c.sent()];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    Oidc.prototype.loginCallbackWithAutoTokensRenewAsync = function () {
        return loginCallbackWithAutoTokensRenewAsync(this);
    };
    Oidc.prototype.userInfoAsync = function () {
        return userInfoAsync(this);
    };
    Oidc.prototype.destroyAsync = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.serviceWorker) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.serviceWorker.clearAsync()];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        if (!this.session) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.session.clearAsync()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4:
                        this.tokens = null;
                        this.userInfo = null;
                        this.events = [];
                        timer_1.default.clearTimeout(this.timeoutId);
                        return [2 /*return*/];
                }
            });
        });
    };
    Oidc.prototype.logoutAsync = function (callbackPath) {
        if (callbackPath === void 0) { callbackPath = undefined; }
        return __awaiter(this, void 0, void 0, function () {
            var configuration, oidcServerConfiguration, path, url;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        configuration = this.configuration;
                        return [4 /*yield*/, this.initAsync(configuration.authority, configuration.authority_configuration)];
                    case 1:
                        oidcServerConfiguration = _a.sent();
                        // TODO implement real logout
                        if (callbackPath && (typeof callbackPath !== 'string')) {
                            callbackPath = undefined;
                            console.warn('callbackPath path is not a string');
                        }
                        path = callbackPath || location.pathname + (location.search || '') + (location.hash || '');
                        url = window.location.origin + path;
                        return [4 /*yield*/, this.destroyAsync()];
                    case 2:
                        _a.sent();
                        if (oidcServerConfiguration.endSessionEndpoint) {
                            window.location.href = oidcServerConfiguration.endSessionEndpoint + "?post_logout_redirect_uri=" + encodeURI(url);
                        }
                        else {
                            window.location.reload();
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    Oidc.eventNames = eventNames;
    return Oidc;
}());
exports.Oidc = Oidc;
exports.default = Oidc;
//# sourceMappingURL=oidc.js.map